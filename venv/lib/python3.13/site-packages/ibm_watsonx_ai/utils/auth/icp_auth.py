#  -----------------------------------------------------------------------------------------
#  (C) Copyright IBM Corp. 2025.
#  https://opensource.org/licenses/BSD-3-Clause
#  -----------------------------------------------------------------------------------------
from __future__ import annotations

from datetime import datetime, timedelta
from typing import TYPE_CHECKING, Callable

from ibm_watsonx_ai.utils.auth.base_auth import (
    STATUS_FORCELIST,
    RefreshableTokenAuth,
    TokenInfo,
)
from ibm_watsonx_ai.utils.utils import _requests_retry_session
from ibm_watsonx_ai.wml_client_error import (
    AuthenticationError,
    CannotAutogenerateBedrockUrl,
    InvalidCredentialsError,
    WMLClientError,
)

if TYPE_CHECKING:
    from ibm_watsonx_ai import APIClient


class ICPAuth(RefreshableTokenAuth):
    """ICP token authentication method class.

    :param api_client: initialized APIClient object with set project or space ID
    :type api_client: APIClient

    :param on_token_creation: callback which allows to notify about token creation
    :type on_token_creation: function which takes no params and returns nothing, optional

    :param on_token_refresh: callback which allows to notify about token refresh
    :type on_token_refresh: function which takes no params and returns nothing, optional
    """

    def __init__(
        self,
        api_client: APIClient,
        on_token_creation: Callable[[], None] | None = None,
        on_token_refresh: Callable[[], None] | None = None,
    ) -> None:
        RefreshableTokenAuth.__init__(
            self, api_client, on_token_creation, on_token_refresh
        )
        self._has_attr_is_bedrock_url_autogenerated = hasattr(
            api_client, "_is_bedrock_url_autogenerated"
        )
        self._is_bedrock_url_autogenerated = (
            getattr(api_client, "_is_bedrock_url_autogenerated")
            if self._has_attr_is_bedrock_url_autogenerated
            else None
        )

        if api_client.CLOUD_PLATFORM_SPACES:
            raise WMLClientError("Authentication method supported only on ICP.")

        if self._api_client.credentials.username is None:
            raise WMLClientError("`username` missing in credentials.")

        if (
            self._api_client.credentials.api_key is None
            and self._api_client.credentials.password is None
        ):
            raise WMLClientError(
                "Api key or password needs to be provided in the credentials."
            )

    def _generate_token(self) -> TokenInfo:
        """Generate token for ICP from scratch using user provided credentials.

        :returns: token info to be used by auth method
        :rtype: TokenInfo
        """
        if (
            self._api_client.credentials.bedrock_url is None
            or self._api_client.credentials.password is None
        ):
            return self._get_cpd_token_from_request_old_auth_flow()

        try:
            return self._get_cpd_token_from_request_new_auth_flow()
        except Exception as e1:
            if not self._has_attr_is_bedrock_url_autogenerated:
                raise e1

            try:
                token_info = self._get_cpd_token_from_request_old_auth_flow()
                # if it worked when iamintegration=False, then removing bedrock_url will shorten the path
                self._api_client.credentials.bedrock_url = None
                return token_info
            except Exception as e2:
                if (
                    self._has_attr_is_bedrock_url_autogenerated
                    and self._is_bedrock_url_autogenerated
                ):
                    raise CannotAutogenerateBedrockUrl(e1, e2)
                else:
                    raise e2

    def _get_cpd_token_from_request_old_auth_flow(self) -> TokenInfo:
        token_url = self._api_client._href_definitions.get_cpd_token_endpoint_href()
        response = _requests_retry_session(status_forcelist=STATUS_FORCELIST).post(
            token_url,
            headers={"Content-Type": "application/json"},
            data=self._get_cpd_auth_pair(),
        )

        if response.status_code == 200:
            return TokenInfo(response.json().get("token"))
        elif 400 <= response.status_code < 500:
            raise InvalidCredentialsError(reason=response.text)
        else:
            raise AuthenticationError("ICP", response)

    def _get_cpd_token_from_request_new_auth_flow(self) -> TokenInfo:
        bedrock_url = (
            self._api_client._href_definitions.get_cpd_bedrock_token_endpoint_href()
        )
        response = _requests_retry_session(status_forcelist=STATUS_FORCELIST).post(
            bedrock_url,
            headers={"Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"},
            data=self._get_cpd_bedrock_auth_data(),
        )

        if 400 <= response.status_code < 500:
            raise InvalidCredentialsError(reason=response.text, logg_messages=False)
        elif response.status_code != 200:
            raise AuthenticationError("ICP", response)

        iam_token = response.json()["access_token"]
        expiration_datetime = datetime.now() + timedelta(
            seconds=response.json()["expires_in"]
        )

        token_url = (
            self._api_client._href_definitions.get_cpd_validation_token_endpoint_href()
        )
        response = _requests_retry_session(status_forcelist=STATUS_FORCELIST).get(
            token_url,
            headers={
                "username": self._api_client.credentials.username,
                "iam-token": iam_token,
            },
        )

        if response.status_code == 200:
            return TokenInfo(response.json()["accessToken"], expiration_datetime)
        else:
            raise InvalidCredentialsError(reason=response.text)

    async def _agenerate_token(self) -> TokenInfo:
        """Generate token for ICP from scratch using user provided credentials.

        :returns: token info to be used by auth method
        :rtype: TokenInfo
        """
        if (
            self._api_client.credentials.bedrock_url is None
            or self._api_client.credentials.password is None
        ):
            return await self._aget_cpd_token_from_request_old_auth_flow()

        try:
            return await self._aget_cpd_token_from_request_new_auth_flow()
        except Exception as e1:
            if not self._has_attr_is_bedrock_url_autogenerated:
                raise e1

            try:
                token_info = await self._aget_cpd_token_from_request_old_auth_flow()
                # if it worked when iamintegration=False, then removing bedrock_url will shorten the path
                self._api_client.credentials.bedrock_url = None
                return token_info
            except Exception as e2:
                if (
                    self._has_attr_is_bedrock_url_autogenerated
                    and self._is_bedrock_url_autogenerated
                ):
                    raise CannotAutogenerateBedrockUrl(e1, e2)
                else:
                    raise e2

    async def _aget_cpd_token_from_request_old_auth_flow(self) -> TokenInfo:
        token_url = self._api_client._href_definitions.get_cpd_token_endpoint_href()
        response = await self._async_httpx_client.post(
            token_url,
            headers={"Content-Type": "application/json"},
            content=self._get_cpd_auth_pair(),
        )

        if response.status_code == 200:
            return TokenInfo(response.json().get("token"))
        else:
            raise InvalidCredentialsError(reason=response.text)

    async def _aget_cpd_token_from_request_new_auth_flow(self) -> TokenInfo:
        bedrock_url = (
            self._api_client._href_definitions.get_cpd_bedrock_token_endpoint_href()
        )
        response = await self._api_client._async_httpx_client.post(
            bedrock_url,
            headers={"Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"},
            content=self._get_cpd_bedrock_auth_data(),
        )

        if response.status_code != 200:
            raise InvalidCredentialsError(reason=response.text, logg_messages=False)

        iam_token = response.json()["access_token"]
        expiration_datetime = datetime.now() + timedelta(
            seconds=response.json()["expires_in"]
        )

        token_url = (
            self._api_client._href_definitions.get_cpd_validation_token_endpoint_href()
        )
        response = await self._api_client._async_httpx_client.get(
            token_url,
            headers={
                "username": self._api_client.credentials.username,
                "iam-token": iam_token,
            },
        )

        if response.status_code == 200:
            return TokenInfo(response.json()["accessToken"], expiration_datetime)
        elif 400 <= response.status_code < 500:
            raise InvalidCredentialsError(reason=response.text)
        else:
            raise AuthenticationError("ICP", response)

    def _get_cpd_auth_pair(self) -> str:
        """Get a pair of credentials required for the token generation.

        :return: string representing a dictionary of authentication credentials
                         (username & password) or (username & api_key).
        :rtype: str
        """
        if self._api_client.credentials.api_key is not None:
            return f'{{"username": "{self._api_client.credentials.username}", "api_key": "{self._api_client.credentials.api_key}"}}'
        else:
            return f'{{"username": "{self._api_client.credentials.username}", "password": "{self._api_client.credentials.password}"}}'

    def _get_cpd_bedrock_auth_data(self) -> str:
        """Get the data required for the token generation.

        :return: string representing a dictionary of authentication credentials
        :rtype: str
        """
        return f"grant_type=password&username={self._api_client.credentials.username}&password={self._api_client.credentials.password}&scope=openid"
